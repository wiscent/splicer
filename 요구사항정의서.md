# 📋 Image Slit Splicer Pro 상세 요구사항 정의서 (v2.6)

## 1. 프로젝트 개요

- **명칭:** Image Slit Splicer Pro
  
- **목적:** 이미지의 불필요한 구간을 슬릿(Slit) 기반의 폴딩(Folding) 기법으로 제거하고, 남은 영역을 자연스럽게 병합하는 도구.
  
- **핵심 알고리즘:** 1. **Splicing Engine:** 소스 이미지의 유효 구간만 추출하여 빈틈없이 배치하는 렌더링 로직.
  
  2. **Visual Pinning:** 폴딩 조작 시 사용자가 잡고 있는 지점(슬릿 라인)이 화면상에서 이동하지 않도록 캔버스 좌표를 역보정하는 물리 로직.
    
  3. **1/3 Intelligent Placement:** 현재 선택된 맥락에 맞게 최적의 다음 슬릿 위치를 계산하는 배치 로직.
    

## 2. 기술 스택 및 좌표계 정의

- **환경:** HTML5 Canvas 2D, Tailwind CSS, Vanilla JS (ES6+).
  
- **좌표계 (매우 중요):**
  
  - **Source Coordinate (S):** 원본 이미지의 픽셀 좌표 (0 ~ originalImg.height).
    
  - **Canvas Coordinate (C):** 폴딩이 적용되어 병합된 결과물의 좌표 (0 ~ mainCanvas.height).
    
  - **Viewport Coordinate (V):** 브라우저 화면상의 좌표. `V = (C * displayScale) + canvasPos.y`.
    

## 3. 핵심 기능 요구사항

### F-1. 이미지 로드 및 초기화

- 이미지를 업로드하면 즉시 `fitToViewport` 로직을 실행함.
  
- **Auto-Fit (95% Rule):** 이미지의 너비가 뷰포트 너비의 95%가 되도록 `displayScale`을 계산함.
  
- **초기 슬릿:** 이미지 로드 시 소스 좌표의 40% 지점에 첫 번째 슬릿을 생성하고 `Active` 상태로 설정함.
  

### F-2. 슬릿 관리 시스템

- **데이터 구조:** `slits: Array<{ id, number, y: SourceY, topFold: Px, bottomFold: Px }>`.
  
- **번호 시스템:** 고유 카운터를 사용하여 생성 순서대로 `#1, #2...` 부여. 삭제되어도 기존 번호 유지.
  
- **Active 상태:** 마지막 클릭/터치된 슬릿 또는 신규 추가된 슬릿. 강조 효과 및 조작의 기준점이 됨.
  

### F-3. 지능형 1/3 배치 알고리즘 (Add Slit)

신규 슬릿의 **SourceY** 위치는 다음 단계로 결정됨:

1. **기준 상단:** 현재 `Active` 슬릿의 `CanvasY` 지점.
  
2. **기준 하단 (LimitCanvasY):**
  
  - `Active` 슬릿 바로 아래에 슬릿이 있고, 그 슬릿의 화면 좌표가 뷰포트 내에 있다면: **그 슬릿의 CanvasY**.
    
  - 위 조건이 아니며 이미지의 하단 끝이 뷰포트 내에 보인다면: **이미지 하단 끝 (CanvasHeight)**.
    
  - 모두 해당되지 않으면 (이미지 하단이 화면 밖): **뷰포트 최하단의 Canvas 좌표**.
    
3. **위치 계산:** `targetCanvasY = 기준상단 + (기준하단 - 기준상단) / 3`.
  
4. **역매핑:** `targetCanvasY`를 `mapCanvasToSource` 함수를 통해 `SourceY`로 변환하여 저장.
  

## 4. 인터랙션 및 조작 로직 (Interaction)

### I-1. 통합 이벤트 핸들러 (Touch/Mouse Hybrid)

- **우선순위 판정:**
  
  1. **Pan Mode:** Space 바 입력 중이거나 'Move View' 모드일 때 -> 전체 화면 이동.
    
  2. **Hit Test:** 클릭/터치 지점과 모든 슬릿의 화면상 `CanvasY` 거리를 비교.
    
  3. **Move Slit:** 가장 가까운 슬릿과의 거리가 **30px 이내**일 때 -> 슬릿의 `y(SourceY)` 좌표 이동.
    
  4. **Folding:** 위 조건이 아닐 때, 현재 `Active` 슬릿의 `CanvasY` 보다 위를 잡으면 `topFold`, 아래를 잡으면 `bottomFold` 조작.
    

### I-2. 비주얼 피닝 (Visual Pinning) 알고리즘

- **상단 폴딩(`topFold`) 조작 시:** 사용자가 드래그한 만큼 `topFold` 값이 변하면 결과물 캔버스의 높이가 실시간으로 변함. 이때 슬릿 라인이 화면에서 튀지 않도록 보정해야 함.
  
- **수식:** `newCanvasY = getSlitCanvasY(activeSlit)`.
  
  `state.canvasPos.y += (initialSlitCanvasY - newCanvasY) * state.displayScale`.
  
- 이 보정 로직을 통해 사용자는 이미지가 슬릿 안으로 '빨려 들어가는' 물리적 경험을 하게 됨.
  

## 5. 핵심 알고리즘 및 렌더링 (Engine)

### E-1. Splicing Engine (Rendering)

1. 슬릿을 `y(SourceY)` 기준으로 오름차순 정렬.
  
2. **구간(Segment) 추출 로직:**
  
  - `prevSourceEnd = 0`에서 시작.
    
  - 각 슬릿에 대해 `segEnd = Math.max(prevSourceEnd, slit.y - slit.topFold)`.
    
  - `[prevSourceEnd, segEnd]` 구간을 캔버스에 그림.
    
  - `prevSourceEnd = Math.max(segEnd, slit.y + slit.bottomFold)`로 갱신하여 다음 구간 준비.
    
3. **Anti-Aliasing 방지:** 모든 좌표 계산과 `drawImage` 호출 시 `Math.round()`를 적용하여 픽셀 틈새 발생 방지.
  

### E-2. 좌표 역매핑 (mapCanvasToSource)

- 캔버스의 특정 `y` 지점이 원본 이미지의 어느 `y` 지점인지 계산하기 위해, 위 렌더링 루프와 동일한 논리로 구간별 오프셋을 역추적하여 소스 좌표를 반환함.

## 6. UI/UX 요구사항

### U-1. 반응형 레이아웃

- **모바일 대응:** 640px 미만 화면에서는 헤더 버튼 텍스트를 아이콘이나 짧은 단어로 축약. 삭제 버튼 크기를 28px 이상으로 확대하여 터치 편의성 제공.
  
- **줌 컨트롤:** 화면 우측 하단에 플로팅 버튼 배치. 모바일 세로 모드(너비 좁음)에서는 숨기고 핀치 줌에 의존.
  
- **상태바:** `ZOOM: %`, `SLITS: N`, `ACTIVE: #N`, `MODE: EDIT/MOVE` 정보를 실시간 표시.
  

### U-2. 조작 가이드

- **Space Key:** 편집 중 언제든 누르면 일시적으로 '화면 이동' 모드로 전환.
  
- **Pinch Zoom:** 두 손가락 터치 시 `displayScale`을 0.05배 ~ 10배 범위 내에서 조절.
  
- **Preview Hold:** '미리보기' 버튼을 누르고 있는 동안 `slit-line`, `label`, `zoom-controls` 등 모든 UI 가이드를 숨김.
  

## 7. 예외 처리 및 방어 코드

- **최소 간격:** 슬릿 이동 시 다른 슬릿과 최소 **2px**의 소스 좌표 간격을 강제 유지.
  
- **최소 수량:** 슬릿이 1개일 때는 삭제 버튼을 숨기거나 작동하지 않게 함.
  
- **초기화:** `Reset` 또는 이미지 재로드 시 캔버스 위치(`canvasPos`)와 스케일(`displayScale`)을 `fitToViewport` 기준으로 초기화.