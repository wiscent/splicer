# 📋 Image Slit Splicer Pro 상세 요구사항 정의서 (v3.0)

## 1. 프로젝트 개요

- **명칭:** Image Slit Splicer Pro
  
- **목적:** 이미지의 불필요한 구간을 슬릿(Slit) 기반의 폴딩(Folding) 기법으로 제거하고, 남은 영역을 자연스럽게 병합하는 고성능 웹 편집 도구.
  
- **핵심 엔진 알고리즘:**
  
  1. **Splicing Engine:** 슬릿과 폴딩 값이 적용된 소스 이미지의 유효 구간들을 계산하여 단일 캔버스에 틈새 없이 드로잉하는 렌더링 로직.
    
  2. **Visual Pinning (물리 보정):** 상단 폴딩 조작 시, 결과물 높이 변화에 맞춰 캔버스 좌표(`canvasPos.y`)를 실시간 역보정하여 사용자가 조작 중인 슬릿 라인이 화면상에서 고정된 것처럼 보이게 함.
    
  3. **Intelligent 1/3 Placement:** 현재 뷰포트 상태와 슬릿 배치 맥락을 분석하여 최적의 다음 슬릿 위치를 자동으로 계산하는 배치 로직.
    

## 2. 기술 스택 및 좌표계 정의

- **환경:** HTML5 Canvas 2D, Tailwind CSS v4, Vanilla JavaScript (ES6+).
  
- **좌표계 (Coordinate Systems):**
  
  - **Source Coordinate (S):** 원본 이미지의 픽셀 좌표 ($0 \sim \text{originalImg.height}$).
    
  - **Canvas Coordinate (C):** 폴딩이 적용되어 병합된 결과물(Main Canvas)의 좌표 ($0 \sim \text{mainCanvas.height}$).
    
  - **Viewport Coordinate (V):** 브라우저 화면(Editor Viewport)상의 좌표.
    
    - $V = (C \times \text{displayScale}) + \text{state.canvasPos}$.

## 3. 핵심 기능 요구사항

### 3.1 이미지 로드 및 자동 최적화

- **Auto-Fit (95% Rule):** 이미지가 로드되면 뷰포트 너비의 95%에 맞춰 `displayScale`을 자동 계산하여 한눈에 들어오게 함.
  
- **최초 슬릿 생성:** 이미지 로드 직후 `fitToViewport`를 실행하고, 화면 기준 상단 1/3 지점에 첫 번째 슬릿을 자동 생성하여 즉시 편집 가능 상태로 만듦.
  

### 3.2 지능형 슬릿 배치 알고리즘 (Add Slit)

새로운 슬릿 추가 시 다음 단계에 따라 **SourceY**를 결정함:

1. **기준점:** 현재 활성화된 슬릿(`activeSlitId`)의 `CanvasY` 지점을 시작점으로 설정.
  
2. **한계점 (LimitCanvasY) 결정:**
  
  - 활성 슬릿 바로 아래에 다른 슬릿이 있고 뷰포트 내에 있다면: 해당 슬릿의 `CanvasY`.
    
  - 위 조건이 아니며 이미지 하단 끝이 뷰포트 내에 있다면: 이미지 하단(`mainCanvas.height`).
    
  - 둘 다 아니면: 뷰포트 최하단에 해당하는 `CanvasY` 좌표.
    
3. **위치 계산:** `targetCanvasY = 기준점 + (한계점 - 기준점) / 3`.
  
4. **역매핑:** 계산된 `targetCanvasY`를 `mapCanvasToSource` 함수를 통해 원본 좌표 `y`로 변환하여 저장.
  

### 3.3 슬릿 데이터 구조 및 관리

- **Data Model:** `Array<{ id, number, y, topFold, bottomFold }>`.
  
- **번호 체계:** 고유 카운터를 사용해 `#1, #2...`와 같이 생성 순서대로 부여 (삭제 시에도 기존 번호 유지).
  
- **Active 상태:** 마지막으로 상호작용한 슬릿을 `activeSlitId`로 관리하며 UI 하이라이트(오렌지색 글로우) 적용.
  

## 4. 인터랙션 및 조작 로직

### 4.1 통합 이벤트 핸들러 (Hybrid Input)

- **Pan Mode (이동):** Space 키가 눌려 있거나 `isPanMode`가 활성화된 경우 전체 화면 이동.
  
- **Hit Test (충돌 판정):**
  
  - 클릭 지점과 슬릿의 화면 좌표($V$) 거리를 비교.
    
  - 거리 < **30px** (`SLIT_HIT_THRESHOLD`): **Move Slit** (슬릿 위치 이동).
    
  - 거리 > 30px: 슬릿 라인 상단 클릭 시 **Fold Top**, 하단 클릭 시 **Fold Bottom** 조작 시작.
    

### 4.2 비주얼 피닝 (Visual Pinning) 알고리즘

- **동작 원리:** 상단 폴딩(`topFold`) 조작 시 캔버스 높이가 변하면서 하위 요소들의 좌표가 밀려 올라가는 현상을 방지.
  
- **수식:**
  
  1. 조작 시작 시 슬릿의 캔버스 좌표($initialSlitCanvasY$) 저장.
    
  2. 조작 중 실시간 캔버스 좌표($newCanvasY$) 계산.
    
  3. `state.canvasPos.y += (initialSlitCanvasY - newCanvasY) * state.displayScale`를 통해 좌표 보정.
    

### 4.3 줌 및 뷰 제어

- **Pinch Zoom:** 모바일에서 두 손가락 조작 시 중심점 기준 $0.05 \sim 10$배율 조절.
  
- **Preview Mode:** '미리보기' 버튼을 누르고 있는 동안 가이드라인, 라벨, 삭제 버튼 등 모든 편집 UI를 일시적으로 은닉.
  

## 5. 엔진 및 렌더링 (Splicing Engine)

### 5.1 렌더링 파이프라인

1. 슬릿을 원본 좌표 `y` 기준으로 오름차순 정렬.
  
2. **구간 추출 로직:**
  
  - `prevSourceEnd = 0`에서 시작.
    
  - 각 슬릿에 대해 `segEnd = Math.max(prevSourceEnd, slit.y - slit.topFold)`.
    
  - `[prevSourceEnd, segEnd]` 구간을 `drawImage`로 렌더링.
    
  - `prevSourceEnd = Math.max(segEnd, slit.y + slit.bottomFold)`로 갱신.
    
3. 이미지 하단 끝까지 남은 구간이 있다면 최종 렌더링.
  
4. **Pixel Accuracy:** 모든 좌표와 크기에 `Math.round()`를 적용하여 서브픽셀 렌더링으로 인한 선 발생 방지.
  

### 5.2 좌표 역매핑 (mapCanvasToSource)

- 캔버스 상의 임의의 점 $C_y$가 원본 이미지의 $S_y$ 어디에 해당하는지 역추적. 슬릿에 의해 가려진(Folded) 영역을 건너뛰며 정확한 소스 좌표를 반환.

## 6. UI/UX 및 예외 처리

### 6.1 반응형 디자인

- **모바일 최적화:** 640px 미만에서 헤더 요소 레이아웃 변경 및 버튼 텍스트 축약. 터치 정확도를 위해 삭제 버튼 크기 보정.
  
- **Status Bar:** 하단 푸터에 `SRC`, `OUT`, `ZOOM`, `SLITS`, `ACTIVE`, `MODE` 정보를 실시간 출력.
  

### 6.2 방어 코드 및 제약 사항

- **최소 간격:** 슬릿 간 이동 시 최소 **2px**(`MIN_GAP_DRAG`) 거리 강제 유지.
  
- **최소 수량:** 슬릿이 1개만 남은 경우 삭제 버튼을 비활성화하여 최소 한 개의 편집점 유지.
  
- **오류 방지:** 이미지 미로드 시 조작 버튼들을 `disabled` 처리하고 'Ready to Splicing' 플레이스홀더 표시.
  
- **PWA 지원:** `Service Worker`를 통한 오프라인 편집 및 앱 설치 기능 제공.